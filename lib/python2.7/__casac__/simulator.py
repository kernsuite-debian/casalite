# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_simulator')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_simulator')
    _simulator = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_simulator', [dirname(__file__)])
        except ImportError:
            import _simulator
            return _simulator
        if fp is not None:
            try:
                _mod = imp.load_module('_simulator', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _simulator = swig_import_helper()
    del swig_import_helper
else:
    import _simulator
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class simulator(_object):
    """Proxy of C++ casac::simulator class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, simulator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, simulator, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _simulator.delete_simulator
    __del__ = lambda self: None

    def __init__(self):
        """__init__(self) -> simulator"""
        this = _simulator.new_simulator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def open(self, *args, **kwargs):
        """
        open(self, ms) -> bool



        Summary
        	Construct a simulator tool and create a new MeasurementSet

        Description

            A simulator tool can either operate on an existing MeasurementSet,
            predicting and/or corrupting data on the existing uvw coordinates 

            -- to do that open the MS with sm.openfromms(msname). 

            or it can be used to create a new MeasurementSet from descriptions of 
            the array configuration and the observational parameters 

            -- to create a new MS, use this method sm.open(msname).

            You will also need to run setconfig, setfield, setspw, setspwindow, 
            setfeed, and settimes.

            Creating the actual (empty) MS is accomplished with sm.observe.  
            Data can be subsequently sm.predict-ed and sm.corrupt-ed.  

            NOTE: sm.predict assumes the model image units are Jy/pixel, and 
              in fact will overwrite the brightness units of the image itself!


        Input Parameters:
        	ms		 MeasurementSet to be created 

        Example:

            In this example, we read in the antenna coordinates from an ASCII file, 
            and simulate a single-pointing VLA observation with a calibrator. 
            Note that no primary beam attenuation will be applied (see sm.setvp).

            tabname = 'VLAC.LOCAL.TAB'
            asciifile = 'VLAC.LOCAL.STN'
            mytab=table.create()
            mytab.fromascii(tabname, asciifile);
            xx=[]; yy:=[]; zz:=[]; diam:=[];
            xx = mytab.getcol('X');  
            yy = mytab.getcol('Y');
            zz = mytab.getcol('Z');
            diam = mytab.getcol('DIAM');
            #
            sm.open('NEW1.ms')
            # do configuration
            posvla = me.observatory('vla');  #  me.observatory('ALMA') also works!
            sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam, 
        	         mount='alt-az', antname='VLA',
                         coordsystem='local', referencelocation=posvla);

            # Initialize the spectral windows    
            sm.setspwindow(spwname='CBand', freq='5GHz',
        		   deltafreq='50MHz',
        		   freqresolution='50MHz',
        		   nchannels=1,
        		   stokes='RR RL LR LL');
            sm.setspwindow(spwname='LBand', freq='1.420GHz',
        		   deltafreq='3.2MHz',
        		   freqresolution='3.2MHz',
        		   nchannels=32,
        		   stokes='RR LL');

            # Initialize the source and calibrater
            sm.setfield(sourcename='My cal',
        		sourcedirection=['J2000','00h0m0.0','+45.0.0.000'],
        		calcode='A');
            sm.setfield(sourcename='My source',
        		sourcedirection=['J2000','01h0m0.0','+47.0.0.000']);

            sm.setlimits(shadowlimit=0.001, elevationlimit='8.0deg');
            sm.setauto(autocorrwt=0.0);

            sm.settimes(integrationtime='10s', usehourangle=F, 
                        referencetime=me.epoch('utc', 'today'));

            sm.observe('My cal', 'LBand', starttime='0s', stoptime='300s');
            sm.observe('My source', 'LBand', starttime='310s', stoptime='720s');
            sm.observe('My cal', 'CBand', starttime='720s', stoptime='1020s');
            sm.observe('My source', 'CBand', starttime='1030s', stoptime='1500s');

            sm.setdata(spwid=1, fieldid=1);
            sm.predict(imagename='M31.MOD');
            sm.setdata(spwid=2, fieldid=2);
            sm.predict(imagename='BigLBand.MOD');
            sm.close();    

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_open(self, *args, **kwargs)


    def openfromms(self, *args, **kwargs):
        """
        openfromms(self, ms) -> bool



        Summary
        	Construct a simulator tool using an already existing  MS

        Description

            A simulator tool can either operate on an existing MeasurementSet,
            predicting and/or corrupting data on the existing uvw coordinates
            - to do that open the MS with sm.openfromms(msname)    
            or it can be used to create a new MeasurementSet from descriptions of
            the array configuration and the observational parameters.
            - to create a new MS, use sm.open(msname).

            NOTE: sm.predict assumes the model image units are Jy/pixel, and in
              fact will overwrite the brightness units of the image itself!


        Input Parameters:
        	ms		 MeasurementSet to be processed 'MS' 

        Example:

            sm.openfromms('3C273XC1.MS');
            sm.predict('3C273XC1.imagename');
            sm.setnoise(simplenoise='10mJy');
            sm.setgain(interval='100s', amplitude=0.01);
            sm.corrupt();
            sm.close();

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_openfromms(self, *args, **kwargs)


    def close(self):
        """
        close(self) -> bool



        Summary
        	Close the simulator tool

        Description

            Close tools and write data to disk. This is a synonym for done.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_close(self)


    def done(self):
        """
        done(self) -> bool



        Summary
        	Close the simulator tool

        Description

            Close tools and write data to disk. This is a synonym for done.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_done(self)


    def name(self):
        """
        name(self) -> string



        Summary
        	Provide the name of the attached MeasurementSet

        Description

            Returns the name of the attached MeasurementSet.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_name(self)


    def summary(self):
        """
        summary(self) -> bool



        Summary
        	Summarize the current state

        Description

            Writes a summary of the currently set properties to the default logger.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_summary(self)


    def type(self):
        """
        type(self) -> string



        Summary
        	Return the type of this tool

        Description

            This function returns the string `Simulator'.  It is used so that in a
            script, you can make sure this variable is a simulator tool.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_type(self)


    def settimes(self, *args, **kwargs):
        """
        settimes(self, integrationtime, usehourangle=True, referencetime) -> bool



        Summary
        	Set integration time, etc.

        Description

            This method sets values to be used in sm.observe.  

            If usehourangle=False, the start and stop times in sm.observe are
            referenced to referencetime.

            If usehourangle=True, then in sm.observe, starttime/stoptime will be
            interpreted as startha/stopha.
            In that case, the start and stop times are calculated such that the
            start time is later than the reference time, but less than one day
            later.  The hour angles refer to the first source observed.


        Input Parameters:
        	integrationtime	 Integration time 10s 
        	usehourangle	 Use starttime/stoptime as hour angles - else they are referenced to referencetime true 
        	referencetime	 Reference time for starttime and stoptime. Epoch Measure . E.g me.epoch('UTC', '50000.0d') 50000.0d epoch measure 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_settimes(self, *args, **kwargs)


    def observe(self, *args, **kwargs):
        """
        observe(self, sourcename, spwname, starttime, stoptime, add_observation=False, state_sig=True, state_ref=False, state_cal=0.0, state_load=0.0, state_sub_scan=0, state_obs_mode, observer, project) -> bool



        Summary
        	Observe a given configuration

        Description

            Observe a given source with a given spectral window for the specified
            times, including start, stop, integration, and gap times.

            If usehourangle=False (set with settimes), the start and stop times
            are referenced to referencetime.

            If userhourangle=True, starttime/stoptime are interpreted as
            startha/stopha, the start and stop times are calculated such that the
            start time is later than the reference time, but less than one day
            later, and the hour angles refer to the first source observed.

            setconfig, setspwindow, setfeed, and setfield must
            be run before observe can be run.

            See also sm.observemany 


        Input Parameters:
        	sourcename	 Name of source or field (must be specified) None 
        	spwname		 Unique user-supplied name for this spectral window None 
        	starttime	 Start time referenced to referencetime, or start hour angle 0s 
        	stoptime	 Stop time referenced to referencetime, or stop hour angle 3600s 
        	add_observation	 Add a new line to the OBSERVATION subtable for this call false 
        	state_sig	 a new line will be added to STATE if the following don't match true 
        	state_ref	 false 
        	state_cal	 0.0 
        	state_load	 0.0 
        	state_sub_scan	 0 
        	state_obs_mode	 OBSERVE_TARGET.ON_SOURCE 
        	observer	 CASA simulator 
        	project		 CASA simulation 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_observe(self, *args, **kwargs)


    def observemany(self, *args, **kwargs):
        """
        observemany(self, sourcenames, spwname, starttimes, stoptimes, directions, add_observation=False, state_sig=True, state_ref=False, state_cal=0.0, state_load=0.0, state_sub_scan=0, state_obs_mode, observer, project) -> bool



        Summary
        	Observe a given configuration

        Description

            Observe given sources with a given spectral window for the specified
            times, including start, stop, integration, and gap times.

            If usehourangle=False (set with settimes), the start and stop times
            are referenced to referencetime.

            If userhourangle=True, starttime/stoptime are interpreted as
            startha/stopha, the start and stop times are calculated such that the
            start time is later than the reference time, but less than one day
            later, and the hour angles refer to the first source observed.

            See also sm.observe


        Input Parameters:
        	sourcenames	 Name of sources None 
        	spwname		 Unique user-supplied name for this spectral window None 
        	starttimes	 Start times referenced to referencetime, or start hour angle 0s 
        	stoptimes	 Stop time referenced to referencetime, or stop hour angle 3600s 
        	directions	 
        	add_observation	 Add a new line to the OBSERVATION subtable for this call false 
        	state_sig	 a new line will be added to STATE if the following don't match true 
        	state_ref	 false 
        	state_cal	 0.0 
        	state_load	 0.0 
        	state_sub_scan	 0 
        	state_obs_mode	 OBSERVE\_TARGET#ON\_SOURCE 
        	observer	 CASA simulator 
        	project		 CASA simulation 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_observemany(self, *args, **kwargs)


    def setlimits(self, *args, **kwargs):
        """
        setlimits(self, shadowlimit=1e-6, elevationlimit) -> bool



        Summary
        	Set limits for observing

        Description

            Data are flagged for two conditions:

            - Below elevation limit: If either of the antennas point below the
            specified elevation limit then the data are flagged. The elevation is
            calculated correctly for antennas at different locations (such as
            occurs in VLBI).

            - Shadowing: If one antenna shadows another such that the fractional
            (geometric) blockage is greater than the specified limit then the data
            are flagged. No correction for blockage is made for shadowed but
            non-flagged points.


        Input Parameters:
        	shadowlimit	 Maximum fraction of geometrically shadowed area before flagging occurs 1e-6 1e-6 
        	elevationlimit	 Minimum elevation angle before flagging occurs 10deg 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setlimits(self, *args, **kwargs)


    def setauto(self, autocorrwt=0.0):
        """
        setauto(self, autocorrwt=0.0) -> bool



        Summary
        	Set autocorrelation weight

        Description



        Input Parameters:
        	autocorrwt	 Weight to assign autocorrelations (0=none) 0.0 0.0 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setauto(self, autocorrwt)


    def setconfig(self, *args, **kwargs):
        """
        setconfig(self, telescopename, x, y, z, dishdiameter, offset, mount, antname, padname, coordsystem, referencelocation) -> bool



        Summary
        	Set the antenna configuration

        Description

            Set the positions of the antennas.  
            - The name of the telescope will control which voltage pattern 
              is applied to the data (see sm.setvp for details).
            - The diameter(s) will be written to the antenna subtable but 
              ONLY affect the calculated visibilities in sm.predict if 
              telescope=ALMA,ACA,OVRO, *and*  ftmachine=mosaic
              (see sm.setvp for details).
            - simutil::readantenna can be used to read an antenna config. file
              which includes many existing observatories.
              see help for the simobserve task, or the example below


        Input Parameters:
        	telescopename	 Name of the telescope we are simulating (determines VP) VLA 'VLA' 
        	x		 Vector of x values of all antennas [m] 0 [] 
        	y		 Vector of y values of all antennas [m] 0 [] 
        	z		 Vector of z values of all antennas [m] 0 [] 
        	dishdiameter	 Vector of diameters of all antennas [m] 0 [] 
        	offset		 Vector of offset of all antennas [m] 0 [] 
        	mount		 Vector of mount types of all antennas (recognized mounts are 'ALT-AZ', 'EQUATORIAL', 'X-Y', 'ORBITING', 'BIZARRE' ALT-AZ [] 
        	antname		 Vector of names of all antennas A [] 
        	padname		 Vector of names of pads or stations P [] 
        	coordsystem	 Coordinate system of antenna positions [x,y,z], possibilities are 'global', 'local' , 'longlat' global 'global' 
        	referencelocation	 Reference location [required for local coords] Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', -20.2deg', 6000km') or me.observatory('ALMA') ALMA position measure 

        Example:


            # known antenna configurations are stored in the data repository, 
            # for historical reasons under 'alma' even though this includes all
            # known observatories:
            configdir=casa.values()[0]['data']+'/alma/simmos/'

            # please look in that directory if your observatory is present.
            # if so, simutil can be used to read the file:
            from simutil import simutil
            # a simutil must be instantiated to use most methods
            u=simutil()
            x,y,z,d,padnames,telescope,posobs = u.readantenna(configdir+'vla.a.cfg')

            # note that readantenna converts the positions to earth-centered 
            # global, from whatever format is in the configuration file, so 
            # coordsystem='global' should be used in setconfig
            sm.setconfig(telescopename=telescope, x=x, y=y, z=z, 
                         dishdiameter=d.tolist(), 
                         mount=['alt-az'], antname=padnames,
                         coordsystem='global', referencelocation=pospbs);

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setconfig(self, *args, **kwargs)


    def setfeed(self, *args, **kwargs):
        """
        setfeed(self, mode, x, y, pol) -> bool



        Summary
        	Set the feed parameters

        Description

            Specify feed parameters. At this moment, you only have the choice
            between 'perfect R L' and 'perfect X Y' (i.e., you cannot invent
            your own corrupted feeds yet).  Doesn't need to be run if you want
            perfect R and L feeds.


        Input Parameters:
        	mode		 Mode for specifying feed parameters (currently, perfect only) 
        	x		 Some very secretive feed array parameter x 0 
        	y		 Some more very secretive feed array parameter y 0 
        	pol		 R 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setfeed(self, *args, **kwargs)


    def setfield(self, *args, **kwargs):
        """
        setfield(self, sourcename, sourcedirection, calcode, distance) -> bool



        Summary
        	Set one or more observed fields

        Description

            Set one or more observed fields, including name and coordinates.
            Can be invoked multiple times for a complex observation.
            Must be invoked at least once before sm.observe.

            If the distance to the object is set then the phase term includes a
            curvature for the near-field effect at the center of the image.


        Input Parameters:
        	sourcename	 Name of source or field (must be specified) SOURCE 'unknown' 
        	sourcedirection	 Direction Measure of Coordinates of source to be observed. E.g me.direction('J2000', '30.5deg','-20.2deg'). 
        	calcode		 Calibration code 'OBJ' 
        	distance	 Distance to the object 0m 

        Example:


            sm.setconfig(telescopename=telescope, x=x, y=y, z=z, 
                         dishdiameter=d.tolist(), 
                         mount=['alt-az'], antname=padnames,
                         coordsystem='global', referencelocation=pospbs);

            sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=1, stokes='RR
                           LL');
            dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
            sm.setfield(sourcename='SIMU1', sourcedirection=dir0);
            sm.settimes(integrationtime='10s', usehourangle=True, 
                        referencetime=me.epoch('TAI', '2012/01/01/00:00:00'))
            sm.observe(sourcename='SIMU1', spwname='XBAND',
                       starttime='0s', stoptime='3600s')




        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setfield(self, *args, **kwargs)


    def setmosaicfield(self, *args, **kwargs):
        """
        setmosaicfield(self, sourcename, calcode, fieldcenter, xmosp=1, ymosp=1, mosspacing, distance) -> bool



        Summary
        	Set observed mosaic fields

        Description

            Set mosaic fields by internally invoking setfield multiple times.
            Currently only handle a rectangular mosaicing pattern.  Either
            setfield or setmosaicfield must be invoked at least once before
            observe.

            If the distance to the object is set then the phase term includes a
            curvature for the near-field effect at the center of the image.


        Input Parameters:
        	sourcename	 Name of source or field (must be specified). SOURCE 'unknown' 
        	calcode		 Calibration code '' 
        	fieldcenter	 Coordinates of mosaic field center MDirection 
        	xmosp		 Number of mosaic pointing in horizontal direction 1 
        	ymosp		 Number of mosaic pointing in vertical direction 1 
        	mosspacing	 Spacing between mosaic pointings 1arcsec 
        	distance	 Distance to the object 0m 

        Example:


            sm.setconfig(telescopename='VLA', x=xx, y=yy, z=zz, dishdiameter=diam,
                         mount='alt-az', antname='VLA',
                         coordsystem='local', referencelocation=dm.observatory('vla'));

            sm.setspwindow(spwname='XBAND', freq='8GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=1, stokes='RR
                           LL');
            dir0 = me.direction('B1950',  '16h00m0.0', '50d0m0.000')
            sm.setmosaicfield(sourcename='SIMU1', fieldcenter=dir0,
                              xmosp=2, ymosp=2, mosspacing='154.5arcsec');
            sm.settimes(integrationtime='10s');
            sm.observe('SIMU1_1', 'XBAND', starttime='0s', stoptime='100s');
            sm.observe('SIMU1_2', 'XBAND', starttime='110s', stoptime='210s');
            sm.observe('SIMU1_3', 'XBAND', starttime='220s', stoptime='320s');
            sm.observe('SIMU1_4', 'XBAND', starttime='330s', stoptime='430s');



        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setmosaicfield(self, *args, **kwargs)


    def setspwindow(self, *args, **kwargs):
        """
        setspwindow(self, spwname, freq, deltafreq, freqresolution, refcode, nchannels=1, stokes) -> bool



        Summary
        	Set one or more spectral windows

        Description

             Set one or more spectral windows for the observations, including
             starting frequency, number of channels, channel increment and
             resolution, and stokes parameters observed.  Can be invoked
             multiple times for a complex observation.  Must be invoked at
             least once before observe.


        Input Parameters:
        	spwname		 Unique user-supplied name for this spectral window XBAND 'XBAND' 
        	freq		 Starting frequency 8.0e9Hz 
        	deltafreq	 Frequency increment per channel 50e6Hz 
        	freqresolution	 Frequency resolution per channel 50.e6Hz 
        	refcode		 Spectral reference code e.g. LSRK, TOPO, BARY TOPO LSRK LSRD BARY GEO TOPO GALACTO LGROUP CMB 
        	nchannels	 Number of channels 1 
        	stokes		 Stokes types to simulate RR LL 'RR LL' 

        Example:


        To simulate a two spectral window (or two IF's in VLA jargon) data
        set, use setpwid as follows (here we are simulating 16 channels, 50MHz
        wide channel for each spectral window)


        sm.setspwindow(spwname='CBAND', freq='2GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=16, stokes='RR LL');

        sm.setspwindow(spwname='SBAND', freq='5GHz', deltafreq='50MHz',
                           freqresolution='50MHz', nchannels=16, stokes='RR LL');


        Note that the spwname is used in observe to determine which spectral window
        to use.


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setspwindow(self, *args, **kwargs)


    def setdata(self, *args, **kwargs):
        """
        setdata(self, spwid, fieldid, msselect) -> bool



        Summary
        	Set the data parameters selection for subsequent processing

        Description

            This setup tool function selects which data are to be used
            subsequently. After invocation of setdata, only the selected data are
            operated on.


        Input Parameters:
        	spwid		 Spectral Window Ids (0 relative) to select 0 
        	fieldid		 Field Ids (0 relative) to select 0 
        	msselect	 TAQL select string applied as a logical 'and' with the other selections String 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setdata(self, *args, **kwargs)


    def predict(self, *args, **kwargs):
        """
        predict(self, imagename, complist, incremental=False) -> bool



        Summary
        	Predict astronomical data from an image or components

        Description

            Predict astronomical data from an image.  The (u,v) coordinates
            already exist, either from a MeasurementSet we have read in or by
            generating the MeasurementSet coordinates and empty data through
            smobserve.  This method calculates visibilities for those
            coordinates.

            - predict(incremental=False) calculates new visibilities and
              replaces the DATA column,
            - predict(incremental=True) calculates new visibilities, adds
              them to the DATA column
            - predict for any value of incremental then sets CORRECTED_DATA
              equal to DATA, and MODEL_DATA to 1
            * predict assumes model image units are Jy/pixel, and in fact
              will overwrite the brightness units of the image itself!

            * treatment of primary beam depends critically on parameters set in 
              sm.setvp() and sm.setoptions(ftmachine) - see help sm.setvp for 
              details. For componentlists, if sm.setvp() is run prior to predict, then the spectral variation of each component in the componentlist will include the multiplicative term of the beam value for each channel frequency. So a flat spectrum component will show the frequency variation of the beam in the predicted visibilities.



        Input Parameters:
        	imagename	 Name of image from which to predict visibilities 
        	complist	 Name of component list String 
        	incremental	 Add this model to the existing Data Visibilities? false 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_predict(self, *args, **kwargs)


    def setoptions(self, *args, **kwargs):
        """
        setoptions(self, ftmachine, cache=0, tile=16, gridfunction, location, padding=1.3, facets=1, maxdata=2000.0, wprojplanes=1) -> bool



        Summary
        	Set various processing options

        Description

            Set options for predict.  See also imager help.

            To simulate single dish data, use gridft=SD and gridfunction=PB.

            To invoke primary beam convolution in the uv domain, use
            ftmachine='mosaic'.  This is the only option that allows
            heterogeneous array simulation - see the example below and 
            help sm.setvp for more details.


        Input Parameters:
        	ftmachine	 Fourier transform machine. Possibilities are 'ft', 'sd', 'mosaic' ft 'ft' 
        	cache		 Size of gridding cache in complex pixels 0 
        	tile		 Size of a gridding tile in pixels (in 1 dimension) 16 
        	gridfunction	 Gridding function. String: 'SF'|'BOX'|'PB' SF 'SF' 
        	location	 Location used in phase rotations. Position Measure of Coordinates of array location. E.g me.position('ITRF', '30.5deg', '-20.2deg', '6000km') or me.observatory('ALMA') ALMA position measure 
        	padding		 Padding factor in image plane (\>=1.0) 1.3 
        	facets		 Number of facets 1 
        	maxdata		 Maximum data to write to a single TSM file (MB) 2000.0 
        	wprojplanes	 Number of projection planes when using wproject as the ft-machine 1 

        Example:

            # set some options
            sm.setoptions(cache=10000000, tile=32, gridfunction='BOX', me.location('vla'))


            # set ftmachine to invoke uv-domain primary beam convolution, and use that 
            # to simulate a heterogeneous ALMA 7m+12m array.
            from simutil import simutil
            u=simutil()
            configdir=casa.values()[0]['data']+'/alma/simmos/'
            x,y,z,d,padnames,telescope,posobs = u.readantenna(configdir+'alma.cycle5.1.cfg')
            x2,y2,z2,d2,padnames2,telescope2,posobs2 = u.readantenna(configdir+'aca.cycle5.cfg')

            sm.open('new.het.alma.ms')
            sm.setconfig(telescopename='ALMA',
              x=np.append(x,x2),y=np.append(y,y2),z=np.append(z,z2),
              dishdiameter=np.append(d,d2),
              mount=['alt-az'], padname=np.append(padnames,padnames2).tolist(),
              coordsystem='global', referencelocation=posobs)
            sm.setspwindow(spwname='band1', freq='330GHz',
              deltafreq='1GHz',freqresolution='1GHz',nchannels=1,stokes='XX YY')
            sm.setfeed(mode='perfect X Y',pol=[''])
            sm.setlimits(shadowlimit=0.01, elevationlimit='10deg')
            sm.setauto(0.0)
            sm.setfield(sourcename='src1', 
              sourcedirection='ICRS 10:00:00.00 -23.01.22',
              calcode='OBJ', distance='0m')
            sm.setfield(sourcename='src2', 
              sourcedirection='ICRS 10:00:00.00 -23.01.32',
              calcode='OBJ', distance='0m')
            sm.settimes(integrationtime='10s', usehourangle=True, 
              referencetime=me.epoch('TAI', '2012/01/01/00:00:00'))
            etime='600s'
            sm.observe(sourcename='src1', spwname='band1',
              starttime=qa.mul(-1,qa.quantity(etime)),
              stoptime=qa.quantity(0,'s'));
            sm.observe(sourcename='src2', spwname='band1',
              starttime=qa.quantity(0,'s'),
              stoptime=qa.quantity(etime));
            sm.setoptions(ftmachine='mosaic')
            sm.predict(imagename='point.ra10.image')
            sm.done()

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setoptions(self, *args, **kwargs)


    def setvp(self, *args, **kwargs):
        """
        setvp(self, dovp=True, usedefaultvp=True, vptable, dosquint=True, parangleinc, skyposthreshold, pblimit=1.0e-2) -> bool



        Summary
        	Set the voltage pattern model for subsequent processing

        Description

            Set the voltage pattern model (and hence, the primary beam) used
            for a Telecope.  There are currently two ways to set the voltage
            pattern: by using the extensive list of defaults which the system
            knows about, or by creating a voltage pattern description with
            the vpmanager.  If you are
            simulating a telescope which doesn't yet exist, you will need to
            supply a model voltage pattern using
            the vpmanager.

            sm.predict behavior depends critically on the parameters here, and 
            the ftmachine parameter set in sm.setoptions

            sm.predict will always query the vpmanager for a primary beam/VP pattern. 
            if usedefaultvp==True, it will reset the vpmanager first, so that 
              the PB obtained will be the default for the given telescope name
            if usedefaultvp==False, it will check whether vptable is set, and if so, 
              load that table into the vpmanager and use the beams therein.
            if usedefaultvp==False and vptable is not set, it will use whatever is 
              already set in the vpmanager (see example below for overriding a 
              default telescope beam).

            What sm.predict does with the obtained PB depends on the ftmachine and 
            dovp parameters:

            if ftmachine=='mosaic':
            - a message 'Performing Mosaic Gridding' indicates that one is using 
              uv domain convolution for simulating from images.
            - if the primary beam returned by the vpmanager is ALMA, ACA, or OVRO, 
              heterogeneous gridding will be invoked, and the dish diameter set
              in sm.setconfig, or already in the antenna subtable, will be used
              to convolve sky model images.
              for ALMA or ACA, dish diameter =12m will use a 10.7m Airy pattern, 
              and dish diameter =7m will use a 6.25m Airy pattern.
              see help sm.setoptions for an example.
            - otherwise the PB returned by the vpmanager will be used. 
            * heterogeneous simulation only works at present from a sky model
              image, NOT from sky model components. If you want to simulate a 
              heterogeneous array, please add components to an image using 
              ia.modify, and don't specify a component list in sm.predict.
              Homogeneous array simulation from component lists works fine.
            - IF dovp=True, the primary beam returned by the vpmanager will 
              be used to convolve sky model components.  This is not automatically 
              invoked by ftmachine='mosaic', but needs to be set explicitly with 
              sm.setvp() if you are simulating from components in addition to or 
              instead of sky model images.

            if ftmachine=='ft' (the default):
            - a message 'Synthesis Gridding' indicates that if requested with 
              dovp==True, image domain PB convolution will be used.
            - if dovp==True, the primary beam returned by the vpmanager will be 
            used to convolve sky model components and images.



        Input Parameters:
        	dovp		 Multiply by the voltage pattern (ie, primary beam) when simulating true 
        	usedefaultvp	 Look up the default VP for this telescope and frequency? true 
        	vptable		 If usedefaultvp is false, provide a VP Table made with vpmanager Table 
        	dosquint	 Activate the beam squint in the VP model true 
        	parangleinc	 Parallactice angle increment for squint application 360deg 
        	skyposthreshold	 Position threshold on the sky for feed arrays ?? 180deg 
        	pblimit		 Primary beam limit to use in feed arrays ? 1.0e-2 

        Example:

            # use the default primary beam in subsequent sm.predict (according to 
            # whatever telescope name was set in sm.setconfig)
            sm.setvp(dovp=True, usedefaultvp=True)
            sm.predict(imagename='point.ra10.image',complist='point.cl')

            # use an alternate VP table e.g. of the format created by vpmanager:
            sm.setvp(dovp=True, usedefaultvp=False, vptable='MyAlternateVLAPBModel.TAB', dosquint=F);
            sm.predict(imagename='point.ra10.image',complist='point.cl')

            # set a VP and then use it overridding the default
            # (if telescope='NGVLA' was used previously in setconfig, 
            # or if an MS was loaded with observatory name = 'NGVLA')
            vp.setpbairy(telescope='NGVLA',dishdiam='10m',maxrad='5deg')
            sm.setvp(dovp=True,usedefaultvp=False)
            sm.predict(imagename='point.ra10.image',complist='point.cl')


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setvp(self, *args, **kwargs)


    def corrupt(self):
        """
        corrupt(self) -> bool



        Summary
        	Corrupt the data with visibility errors

        Description

            Add errors specified by the set* functions (such as noise, gains,
            polarization leakage, bandpass, etc) to the visibility data.  The
            errors are applied to the DATA and CORRECTED_DATA columns.

            Note that corrupt handles only
            visibility-plane effects, not image-plane effects such as pointing
            errors and voltage patterns, which get applied in predict.  Note, the
            function applies errors to both cross- and auto-correlation data; The
            auto-correlation data are corrupted properly only for the thermalnoise
            set by setnoise.

        Example:


            sm,openfromms('3C273XC1.MS');
            sm.predict('3C273XC1.FAKE.IMAGE');
            sm.setnoise( mode='simplenoise', simplenoise='0.1Jy');
            sm.setpa( mode='calculate');
            sm.corrupt();


        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_corrupt(self)


    def reset(self):
        """
        reset(self) -> bool



        Summary
        	Reset the corruption terms

        Description

            Reset the visibility corruption terms: this means that corrupt
            introduces no errors.

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_reset(self)


    def setbandpass(self, *args, **kwargs):
        """
        setbandpass(self, mode, table, interval, amplitude) -> bool



        Summary
        	Set the bandpasses

        Description

            Set the level of bandpass errors. The error distributions are normal, mean
            zero, with the variances as specified. (Not yet implemented).


        Input Parameters:
        	mode		 Mode of operation. String: 'calculate'|'table' calculate 'calculate' 
        	table		 Name of table '' 
        	interval	 Coherence interval e.g. '1h' 3600s 
        	amplitude	 Variances errors in amplitude and phase 0.0 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setbandpass(self, *args, **kwargs)


    def setapply(self, *args, **kwargs):
        """
        setapply(self, table, type, t=0.0, field, interp, calwt=False, spwmap, opacity=0.0) -> bool



        Summary
        	Arrange for corruption by existing cal tables

        Description

            Arrange for corruption by existing cal tables, in a manner
            exactly analogous to calibrater.setapply.


        Input Parameters:
        	table		 Calibration table name 
        	type		 Component type B BPOLY G GSPLINE D P T TOPAC GAINCURVE 
        	t		 Interpolation interval (seconds) 0.0 
        	field		 Select on field 
        	interp		 Interpolation type (in time) aipslin nearest linear 
        	calwt		 Calibrate weights? false 
        	spwmap		 Spectral windows to apply -1 
        	opacity		 Array-wide zenith opacity (for type='TOPAC') 0.0 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setapply(self, *args, **kwargs)


    def setgain(self, *args, **kwargs):
        """
        setgain(self, mode, table, interval, amplitude) -> bool



        Summary
        	Set the gains

        Description

            Set the level of gain errors.  Gain drift is implemented as
            fractional brownian motion with rms amplitude as specified.
            Interval is not currently used.



        Input Parameters:
        	mode		 Mode of operation. String: 'fbm' fbm 'fbm' 
        	table		 Optional name of table to write '' 
        	interval	 timescale for gain variations NOT USED 10s 
        	amplitude	 amplitude scale (RMS) for gain variations [real,imag] or scalar 0.01 [] 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setgain(self, *args, **kwargs)


    def settrop(self, *args, **kwargs):
        """
        settrop(self, mode, table, pwv=3.0, deltapwv=0.15, beta=1.1, windspeed=7.) -> bool



        Summary
        	Set tropospheric gain corruptions

        Description

            Set up for corruption by the atmosphere - attenuation and increase in 
            noise.


        Input Parameters:
        	mode		 Mode of operation - screen or individual antennas screen 'screen' 
        	table		 Name of optional cal table to write '' 
        	pwv		 total precipitable water vapour in mm 3.0 
        	deltapwv	 RMS PWV fluctuations *as a fraction of PWV parameter* 0.15 
        	beta		 exponent of fractional brownian motion 1.1 
        	windspeed	 wind speed for screen type corruption (m/s) 7. 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_settrop(self, *args, **kwargs)


    def setpointingerror(self, *args, **kwargs):
        """
        setpointingerror(self, epjtablename, applypointingoffsets=False, dopbcorrection=False) -> bool



        Summary
        	Set the Pointing error

        Description

            Set the pointing error from a calpointing table


        Input Parameters:
        	epjtablename	 Name of a table that has E-Jones errors for Pointing 
        	applypointingoffsets	 Apply pointing offsets false 
        	dopbcorrection	 apply primary beam correction false 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setpointingerror(self, *args, **kwargs)


    def setleakage(self, *args, **kwargs):
        """
        setleakage(self, mode, table, amplitude, offset) -> bool



        Summary
        	Set the polarization leakage

        Description

            Set the level of polarization leakage between feeds.
            Currently, no time dependence is available.


        Input Parameters:
        	mode		 Mode of operation. String: 'constant' constant 'constant' 
        	table		 Optional name of table to write '' 
        	amplitude	 Magnitude of pol leakage [real,imag] 0.01 [] 
        	offset		 Meam of pol leakage [real,imag] 0. [] 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setleakage(self, *args, **kwargs)


    def oldsetnoise(self, *args, **kwargs):
        """
        oldsetnoise(self, mode, table, simplenoise, antefficiency=0.8, correfficiency=0.85, spillefficiency=0.85, tau=0.1, trx=50, tatmos=230.0, tcmb=2.7) -> bool



        Summary
        	Set the noise level fixed sigma (mode=simplenoise) or
            Brown's equation (mode=calculate) OBSOLETE VERSION

        Description

            Set various system parameters from which the thermal (ie, random
            additive) noise level will be calculated.

            For mode=simplenoise, one specifies the standard deviation for the
            noise to be added to real and imaginary parts of the visibility.

            For mode=calculate, the noise will vary with dish diameter,
            antenna efficiency, system temperature, opacity, sky temperature,
            etc.  The noise will increase with the airmass if tau is greater
            than zero.  The noise is calculated according to the Brown
            Equation (ie, R.L. Brown's calculation of MMA sensitivity,
            3Oct95): 
            dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) + 
                              T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
                           *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)


        Input Parameters:
        	mode		 Mode of operation. String: 'simplenoise'|'calculate' calculate 'simplenoise' 'calculate' 
        	table		 Name of noise table - not currently implemented '' 
        	simplenoise	 Level of noise (if mode=simplenoise) 0.0Jy 
        	antefficiency	 antenna efficiency 0.8 0.8 
        	correfficiency	 Correlation efficiency 0.85 0.85 
        	spillefficiency	 Forward spillover efficiency 0.85 0.85 
        	tau		 Atmospheric Opacity 0.1 0.1 
        	trx		 Receiver temp (ie, all non-atmospheric Tsys contributions) [K] 50 50 
        	tatmos		 (Physical, not Brightness) Temperature of atmosphere [K] 230.0 230.0 
        	tcmb		 Temperature of cosmic microwave background [K] 2.7 2.7 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_oldsetnoise(self, *args, **kwargs)


    def setnoise(self, *args, **kwargs):
        """
        setnoise(self, mode, table, simplenoise, pground, relhum=20.0, altitude, waterheight, pwv, tatmos=250.0, tau=0.1, antefficiency=0.8, spillefficiency=0.85, correfficiency=0.88, trx=50, tground=270.0, tcmb=2.73, OTF=True, senscoeff=0., rxtype=0) -> bool



        Summary
        	Set the noise level fixed sigma (mode=simplenoise) or
            Brown's equation using the ATM model for frequency-dependent atmospheric
            opacity (mode=tsys-atm) or Brown's equation, manually specifying the zenith
            opacity (constant across the band) and atmospheric temperature 
            (mode=tsys-manual)

        Description

            Set various system parameters from which the thermal (ie, random
            additive) noise level will be calculated.

            For mode=simplenoise, one specifies the standard deviation 'sigma'
            for the noise to be added to real and imaginary parts of the visibility.
            The noise in amplitude per visibility is approximately 'sigma' although 
              it is not Gaussian (see Thompson, Moran, and Swenson fig. 6.9)
            and the point source noise in a Stokes I image will be 
              ~sigma/sqrt(n_pol)/sqrt(n_baselines)/sqrt(n_integrations), 
            where n_pol are the number of polarizations in the MS (typically 2),
            and n_integrations are the number of correlator integration times 
            in the MS (~ track time / int. time)

            For mode=tsys-atm or tsys-atm, the noise will vary with dish
            diameter, antenna efficiency, system temperature, opacity, sky
            temperature, etc.  The noise will increase with the airmass if tau
            is greater than zero.  The noise is calculated according to the
            Brown Equation (ie, R.L. Brown's calculation of MMA sensitivity,
            3Oct95):
            dS = 4*sqrt(2) *( T_rx*exp(-tau_atm) + 
                              T_atm*( exp(tau_atm) - epsilon_l + T_cmb) )
                           *epsilon_q *epsilon_a *pi *D^2 *sqrt(dnu*dt)


            For mode=tsys-atm, the sky brightness temperature is calculated
            using an atmospheric model created for the user-input PWV.  For
            mode=tsys-manual, the user specifies the sky brightness temperature
            manually.


        Input Parameters:
        	mode		 Mode of operation. simplenoise 'simplenoise' 'tsys-atm' 'tsys-manual' 
        	table		 Name of optional cal table to write (if OTF=False) '' 
        	simplenoise	 Level of noise if not calculated by amt 0.1Jy 
        	pground		 Ground pressure for ATM model (if tsys-atm) 560mbar 
        	relhum		 ground relative humidity for ATM model (if tsys-atm) 20.0 
        	altitude	 site altitude for ATM model (if tsys-atm) 5000m 
        	waterheight	 Height of water layer for ATM model (if tsys-atm) 200m 
        	pwv		 Precipitable Water Vapor ATM model (if tsys-atm) 1mm 
        	tatmos		 Temperature of atmosphere [K] (if tsys-manual) 250.0 
        	tau		 Zenith Atmospheric Opacity (if tsys-manual) 0.1 
        	antefficiency	 Antenna efficiency 0.8 
        	spillefficiency	 Forward spillover efficiency 0.85 
        	correfficiency	 Correlation efficiency 0.88 
        	trx		 Receiver temp (ie, all non-atmospheric Tsys contributions) [K] 50 
        	tground		 Temperature of ground/spill [K] 270.0 
        	tcmb		 Temperature of cosmic microwave background [K] 2.73 
        	OTF		 calculate noise on-the-fly (WARNING: only experts with high-RAM machines should use False) true 
        	senscoeff	 sensitivity constant (1./sqrt(2) for interferometer [default]; 1. for total power) 0. 
        	rxtype		 Receiver type; 0=2SB, 1=DSB e.g. ALMA B9 0 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setnoise(self, *args, **kwargs)


    def setpa(self, *args, **kwargs):
        """
        setpa(self, mode, table, interval) -> bool



        Summary
        	Corrupt phase by the parallactic angle

        Description

            Corrupt phase by the parallactic angle


        Input Parameters:
        	mode		 Mode of operation. String: 'calculate'|'table' calculate 'calculate' 
        	table		 Name of table '' 
        	interval	 Interval for parallactic angle application, e.g. '10s' 10s 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setpa(self, *args, **kwargs)


    def setseed(self, seed=185349251):
        """
        setseed(self, seed=185349251) -> bool



        Summary
        	Set the seed for the random number generator

        Description




        Input Parameters:
        	seed		 Seed 185349251 185349251 

        --------------------------------------------------------------------------------

        """
        return _simulator.simulator_setseed(self, seed)

simulator_swigregister = _simulator.simulator_swigregister
simulator_swigregister(simulator)

# This file is compatible with both classic and new-style classes.


